# Chap 08. 함수형 프로그래밍 스터디

> 함수형 프로그래머는 함수형 프로그래밍이 엄청나게 유익하다고 주장합니다. 기존 프로그램보다 한 자릿수나 더 짧은 함수형 프로그램이 생산성은 외려 한 자릿수 더 생산적이라고 하지요

요즘은 웹페이지가 실시간 반응하는 네이티브 애플리케이션처럼 작동하기를 기대합니다.
웹 미들웨어와의 통신, 사용자 입력의 효율적인 처리, 원격 서버 통신, 데이터 화면 표시등 여러가지 일을 한꺼번에 처리하는 부담이 가중되었습니다.

## 골칫덩이 비동기 코드

- 함수 간에 일시적 의존 관계가 형성
- 어쩔 수 없이 콜백 피라미드의 늪에 빠짐
- 동기/비동기 코드의 호환되지 않는 조합

### 함수 간에 일시적 의존 관계가 형성

이벤트가 올바른 순서로 발생하도록 보장하기 위해서는 비동기 코드와 다음 액션사이에 일시적인 관계를 설정해야합니다.

```js
var students = null;

getJSON(url, () => {
  // .....
});
```

일시적 결합은 어떤 함수를 논리적으로 묶어 실행할 때 발생합니다. 원격 IO 작업은 나머지 다른 코드에 비해 속도가 느릴 수 밖에 없습니다.
데이터 요청 후 다시 돌아올때까지 대기 가능한 비차단 프로세스에게 처리를 위임합니다.

### 콜백 피라미드의 늪에 빠짐

콜백의 주용도는 처리 시간이 오래 걸리는 프로세스를 기다리는 도중 UI 를 차단하지 않는 것입니다. 함수형 프로그램의 함수는 서로 독립적이며 호출자에 즉시 반환해야 합니다.

```js
addEventListener("click", () => {
  getJSON(url, () => {
    addEventListener("click", () => {
      // ...
    });
  });
});
```

콜백 순차열을 중첩한 광경이 마치 코드를 수평하게 쌓아놓은 피라미드 같습니다. 이런 상태를 콜백지옥 이라고 부릅니다.

### 연속체 전달 스타일

중첩된 콜백 함수는 읽기도 어렵지만 자기 스코프 및 자신이 중첩된 함수의 변수 스코프를 감싼 클로저를 만듭니다.
함수가 어떤일을 달성하기 위해 자신의 외부 변수에 직접 접근해야 할 경우에만 의미가 있습니다.
내부 콜백함수는 불필요한 외부 데이터를 참조하는 레퍼런스를 고스란히 간직하고 있습니다. 이런 코드를 연속체 전달 스타일로 바꾸어 개설할 수 있습니다.

내부콜백 함수를 개별 함수 또는 람다 표현식으로 나눕니다.
CPS 는 비차단 프로그램의 조각들을 개별 컴포넌트로 분리하기 위한 프로그래밍 스타일입니다.
여기서 콜백 함수는 현재 연속체라고 부르며 함수 자체를 호출자에게 반환값으로 돌려줍니다.

CPS 코딩은 코드에 잔존하는 일시적 의존 관계를 척격하고, 비동기 흐름을 선형적인 함수 평가 형태로 둔갑시키는 능력이 있습니다.

### 비동기 로직을 프라미스로 일급화

함수형 프로그램이라면 이런 특성을 가져야합니다.

- 합성과 무인수 프로그래밍 이용합니다.
- 중첩된 구조를 보다 선형적으로 흐르게 눌러 폅니다.
- 일시적 셜합은 추상하기 때문에 개발자는 더 이상 신경 쓸 필요가 없습니다.
- 여러 콜백 대신, 단일 함수로 에러 처리 로직을 통합하여 코드 흐름을 원하라게 합니다.

프라미스는 오래 걸리는 계산을 모나드로 감싸는 개념입니다.

```js
Promise.of(<오래 걸리는 작업>).map(fun1).map(func2) // => return Promise()
```

기존 모나드와는 다르게 프라미스는 오래 걸리는 계산이 끝날때까지 기다렸다가 미리 매핑한 함수를 실행합니다.
반환값이 불확실한 함수를 Maybe, Either 모나드로 감쌌듯이, 프라미스는 우직하고 투명하게 데이터를 기다리는 개념입니다.
프라미스는 중간에 실패하더라도 Maybe, Either 처럼 비슷하게 에러 처리 로직을 통합하여 대응할 수 있습니다.

프라미스의 상태는 보류, 이룸, 버림, 귀결 중 하나입니다. 다른 객체에 데이터가 당도했음을 통보하고, 처리 도중 에러가 나면
미리 등록한 실패 콜백 함수를 호출합니다.

비동기 작업을 프라미스로 감싸고 이룸/버림 두 콜백을 받는 과정, 프라미스는 처음에 보류 상태로 출발해서 이룸 아니면 버림 상태가 바뀌고, 귀결 상태로 이동하기 전, 각각
resolve 또는 reject 함수를 호출합니다.

### 미래의 메서드 체인

프라미스 객체는 then 메서드를 지닙니다. 프라미스에 보관된 반환값에 연산을 수행하고 다시 프라미스 형태로 되돌리는 메서드입니다.
Maybe.map(f) 처럼 Promise.then(f) 는 데이터 변환 작업을 서로 체이닝하고 여러 함수를 제때 모아 함수 사이의 일시적인 결합을 추상하는 용도로 쓰입니다.
then 메서드의 두 인수는 성공, 실패 콜백입니다.

- 비동기 호출을 중첩하는 대신 then 으로 체이닝하고, 비동기 코드를 프라미스 모나드로 추상화합니다.
- 에러 처리 로직을 제일 마지막의 catchall 함수에 몰아 넣습니다.
- 데이터를 IO 모나드에 승급하여 부수효과 없이 DOM 에 표시합니다.

프라미스는 비동기 흐름을 숨기지만 시간 관념은 then 으로 분명히 드러내기 때문에 getJSON 을 지역 저장소 호출 용도로 프라미스화한 getSJON 으로 쉽게 변경할 수 있습니다.
이런 수준의 유연성을 위치 투명성 이라고 합니다.

### 느긋한 데이터 생성

ES6의 가장 강력한 특성 중 하나는 어떤 함수를 끝까지 실행하지 않아도 데이터 제공을 잠시 중단한 상태로 다른 함수들과 더불어 작동시키는 능력입니다.
제너레이터 함수는 function\* 이라고 표기하는 언어 수준에서 지원되는 장치입니다.
yield 를 만나면 함수 밖으로 잠시 나갔다가 자신의 보관된 콘텍스트를 찾아 다시 돌아오는 독특한 움직임을 보입니다.
일반적인 함수 호추로가 달리, 제너레이터 함수의 실행 콘텍스트는 잠정 중단했다가 언제라도 재개할 수 있어서 제너레이터로 다시 돌아올 수 있습니다.
제너레이터 함수는 함수를 호출하는 시점에 내부적으로 이터레이터 객체를 생성하여 느긋함을 부여하고, 이터레이터는 매번 yield 를 호출할 때마다 호출자에게 데이터를 돌려줍니다.

```js
function *range(start = 0, finish = Number.POSITIVE ) {
  for(let i = start, i < finish; i += 1) {
    yield i;
  }
}

const num = range(1);
num.next().value // 1
num.next().value // 2
num.next().value // 3
```

### 제너레이터와 재귀

일반 함수 호출과 마찬가지로 제너레이터도 다른 제너레이터를 얼마든지 호출할 수 있습니다.
제너레이터는 for..of 루프문으로 반복할 수 있기 때문에 다른 제너레이터에게 위임하는 건 마치 두 컬렉션을 병합한 전체 컬렉션을 반복하는 것과 비슷합니다.

### 이터레이터 프로토콜

자료구조처럼 루프로 반복시킬 수 있는것은 이터레이터 덕분입니다. 제너레이터 함수는 내부적으로 이터레이터 프로토콜에 따라 yield 키워드로 값을 반환하는 next() 메서드가 구현된
Generator 객체를 반환합니다.

- done: 제일 마지막에 이터레이터가 전달되면 true, 그 외에는 false 로 세팅됩니다. false 는 이터레이터가 도중에 다른 값을 생산할 수 있음을 의미합니다.
- value: 이터레이터가 반환한 값 입니다.

```js
function range(start, end) {
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (start < end) {
        return { value: (start += 1), done: false };
      }
      return { done: value, value: end };
    }
  };
}
```

이벤트나 값들을 이산적인 순차열로 만드는 스트림으로 바라보는 습관을 권장합니다.

## ReJS 를 응용한 함수형 리액티브 프로그래밍

웹 애플리케이션 생태계에서 Ajax 의 출현은 일대 혁명을 가져왔습니다. 데이터는 물론 더 긴밀한 상호작용을 원하는 사용자의 기대 수준 또한 높아졌습니다.
애플리케이션은 버튼 클릭, 텍스트 필드 입력, 마우스 움직임, 순가락 제스처, 음성 멸령등 사용자의 입력을 처리할 수 있어야하고, 무엇보다 일관된 방시그로 소통하는것이 중요해졌습니다.
함수형 프라미스 기반의 예제와 비슷한 방식으로 작동하지만 더 높은 수준의 추상화를 제공합니다.

### 옵저블 순차열로서의 데이터

옵저버블은 구독 가능한 모든 객체를 가리킵니다. 리액티브 프로그래밍은 모든 데이터 제공원을 Rx.Observable 객체를 통해 옵저버블 스트림이라는 단일 개념으로 일원화합니다.
스트림이란 시간의 흐름에 따라 발생하는 이벤트의 순차열입니다.

```js
Rx.Observable.range(1, 3).subscribe(
  x => console.log(`다음: ${x}`),
  err => console.log("에러"),
  () => console.log("완료!")
);
```

어떤 자료형 이라도 Rx.Observable 을 이용해서 스트림으로 바꿀 수 있으므로 다루는 방식도 똑같다는 사실을 알 수 있습니다.

### 함수형 리액티브 프로그래밍

Rx.Observable 객체는 함수형과 리액티브 두 프로그래밍을 하나로 묶습니다.
이 객체는 map, of, join 등 최소한의 모나드 인터페이스에 해당하는 구현체와 스트림 조작에 특화된 메서드를 여럿 거느립니다.

```js
Rx.Observable.of(1, 2, 3, 4, 5)
  .filter(x => x % 2 === 0)
  .map(x => x * x)
  .subscribe(x => console.log(x));
```

리액티브 프로그래밍 관련 문서가 대부분 함수형 프로그래밍 기법을 설명하는 것으로 시작할 정도입니다.
스트림을 이용하면 코드를 선언적으로 연산 체이닝하는 형태로 작성하게됩니다.
리액티브 프로그래밍 함수형 프로그래밍 함수형 리액티브 프로그래밍이란 용어까지 출현했습니다.

프라미스로 함수형과 비동기 함수의 부조화를 해결했던 것 처럼 이벤트와 함수형 두 세계를 접목하기 위해 Rx.Observable 를 추상화 계층으로 둡니다.

## 마치며

- 프라미스는 오랫동안 콜백 중심적인 설계를 함수형으로 해결하는 방안입니다.
- 미래의 함수를 프라미스로 합성 체이닝하면 일시적으로 의존 관계가 형성된 코드의 잡다한 저수준 로직을 추상할 수 있습니다.
- 제너레이터는 비동기 코드에 접근하는 또 다른 방안으로 느긋한 이터레이터로 데이터를 쓸 수 있는 시점에 내어주는 프로그래밍 장치입니다.
- 함수형 리액티브 프로그래밍은 프로그램의 추상화 수준을 높여 이벤트를 논리적으로 독립된 단위로 다룰 수 있게 합니다.
