# 8. 비동기 이벤트와 데이터를 관리

- 함수형 기법은 중대형 규모의 웹 어플리케이션을 관리하기 위한 기술이다.
- 웹 어플리케이션의 사용자 요구 수준은 점점 높아지고 있다.
- 다른 환경에 비해 웹 어플리케이션은 많은 것들을 고민해야 한다.
- 높은 수준의 무결성을 지켜야하는 시스템의 이상적인 해결책으로는 함수형 프로그래밍이 딱!

# 8.1 골칫덩이 비동기 코드

- 요즘 자바스크립트 프로그램은 단일 요청으로 페이지가 로드되는 경우가 거의 없다.
- 사용자의 필요에 따라 여러 비동기 요청을 동시에 요청한다.
- 이는 보통 non-blocking 비동기 호출 코드를 사용하여 해결한다.
- 하지만 여러가지 문제가 생긴다

## 8.1.1 함수 간에 일시적 의존 관계가 형성

- 이벤트가 올바른 순서로 발생하도록 보장하기 위해서는 비동기 코드와 그다음 액션 사이에 일시적인 관계를 설정해야 한다.
- 일시적 결합은 어떤 함수를 논리적으로 묶어 실행할 때 발생한다.
- 데이터가 도착할 때까지 혹은 다른 함수가 실행될 때까지 어떤 함수가 기다리는 경우다.
- 이때 사이드 이펙트가 일어난다.
- 원격 IO작업은 나머지 다른 코드에 비해 속도가 느리므로 데이터 요청 후 다시 돌아올 때까지 대기 가능한 non blocking 프로세스에게 처리를 위임한다.
- 개발자가 작성한 콜백함수는 데이터를 받는 시점에 호출된다.

## 8.1.2 콜백 피라미드의 늪에 빠짐

- 콜백의 용도는 처리 시간이 오래 걸리는 프로세스를 기다리는 중에 UI를 차단하지 않는 것이다.
- 콜백은 제어의 역전을 실천하는 것이다.
- 하지만 제어 역전 구조는 함수형 프로그램의 설계 사상과 정면 배치된다.
- 함수형 프로그램에서 함수는 서로 독립적이고 값을 호출자에게 즉시 반환해야 한다.
- 콜백이 많이 중첩되는 상태를 콜백 지옥이라고 부른다.
- 많은 비동기 코드와 사용자 DOM 핸들링이 필요한 경우 자주 목격하게 된다.

## 8.1.3 연속체 전달 스타일

- 중첩된 콜백함수는 자기 스코프 및 중첩된 함수의 변수 스코프를 감싼 클로저를 만든다.
- 내부 콜백함수는 불필요한 외부 데이터를 참조하는 레퍼런스를 간직하게 된다.
- CPS, 연속체 전달 스타일을 사용하면 이런 코드를 개선할 수 있다.
- CPS는 내부 콜백함수를 개별 함수로 바꾼게 전부다.
- CPS의 강점은 Context 스택의 효율성이 좋다는 것이다.
- CPS를 사용하면 코드에 남은 일시적 의존 관계를 정리하고 비동기 흐름을 선형적인 함수 평가 형태로 바꿀 수 있다.
- 하지만 이런 스타일이 익숙치 않으면 혼란스러울 수도 있다.

# 8.2 비동기 로직을 프라미스로 일급화

- 프라미스는 오래 걸리는 계산을 모나드로 감싸는 개념이다.
- 프라미스는 나중에 처리가 끝나는 값이나 함수를 감싼다.
- 프라미스는 이런 작업 도중 실패해도 다른 모나드와 비슷하게 에러 처리 로직을 통합하여 대응할 수 있다.
- 또한 처리할 작업의 상태정보도 제공하기 때문에 데이터를 성공적으로 조회했는지, 에러는 안났는지도 알 수있다.
- 프라미스의 상태는 Pending / Fulfilled / Rejected / Settled 중 하나이다.
  - 처음은 Pending 상태로 시작한다.
  - 그리고 결과에 따라 Resolve 호출하면 Fulfilled,
  - 또는 Reject 호출 시 Rejected 상태로 분기한다.
  - 그리고 각각 `then`혹은 `catch` 가 실행되고 나면 Settled 상태가 된다.
- 프라미스를 쓰면 콜백 헬을 해결할 수 있다.

## 8.2.1 미래의 메서드 체인

- 프라미스 객체의 `then`은 마치 함수자의 `fmap`과 유사하다.
- 데이터 변환 작업을 서로 체이닝하고 여러 함수를 모아서 함수 사이의 일시적인 결합을 추상화 하는 용도로 쓰인다.
- 즉, 비동기 로직을 중첩하지 않고 체이닝할 수 있다.
- API를 Promisify 하면 훨씬 다루기 편하다.
- 프라미스는 비동기 흐름을 숨기지만, 시간관념은 `then`을 통해 분명히 드러낸다.
- 따라서 만약 데이터 소스가 다르더라도 코드는 동일하게 동작한다. 이런 유연성을 위치 투명성(location transparency)라고 한다.
- 비동기 작업을 동시에 Promise로 진행할 수도 있는데 이럴때 쓰는것이 바로 `Promise.all()`이다.

## 8.2.2 동기/비동기 로직을 합성

- 프라미스를 사용하면 동기 프로그램 처럼 모양을 유지하면서 시차를 두고 여러 함수를 나누어 실행할 수 있다.
- `then` 혹은 `catch` 를 커리된 함수로 추상화하여 함수 합성에 사용할 수 있다.
- 이렇게 하면 Promise 체인과 마찬가지로, `then` 이후의 로직은 Async 작업이 끝날 때까지 대기하게 된다.

# 8.3 느긋한 데이터 생성

- ES2015의 Generator를 사용하면 데이터를 느긋하게 생성할 수 있다.
- 느긋한 평가를 가진 언어라면 임의의 크기로 리스트를 생성할 수 있다
- 하지만 자바스크립트는 조급한 평가를 가진 언어이므로 불가능하다. 아래의 코드는 스택이 넘쳐 에러가 난다.

```js
R.range(1, Infinity).take(1);
```

- 제너레이터는 내부적으로 이터레이터 객체를 생성하여 느긋함을 부여한다.

```js
function \*range(start = 0, finish = Number.POSITIVE_INFINITY) {
  for (let i = start; i < finish; i++) {
    yield i;
  }
}

for (let n of range(1)) {
  console.log(n); // 무한 출력
}
```

- `yield` 는 해당 데이터를 호출자에게 돌려주고 다시 실행 될 때까지 지역변수 상태를 모두 기억한다.

## 8.3.1 제너레이터와 재귀

- 제너레이터 역시 재귀를 활용할 수 있다.
- 중첩된 객체 집합을 평평하게 만들고 싶을 때 유용하다.

```js
function* TreeTraversal(node) {
  yield node.value;

  if (node.hasChildren()) {
    for (let child of node.children) {
      yield* TreeTraversal(child);
    }
  }
}
```
