> 문제 풀이

# Chapter 8. 비동기 이벤트와 데이터를 관리

### wrote by. robin

## 8.1 골칫덩이 비동기 코드

- 요즘 자바스크립트 프로그램은 단일 요청으로 로드되는 경우가 거의 없다. => (복잡도 증가) 여러 비동기 요청을 동시에 전송해서 데이터를 페이지에 미리 로드한다.
- 비차단(`non blocking`) 비동기 코드
  - 함수 간에 일시적 의존 관계가 형성
  - 콜백 지옥에 빠짐
  - 동기/비동기 코드가 호환되지 않음

### 함수 간에 일시적 의존 관계가 형성됨

- (문제점) 객체가 바로 초기화 될리 없으므로 실행 흐름이 일시적으로 어긋남 => 이벤트가 올바른 순서로 발생하도록 보장하기 위해서, 비동기 코드와 다음 액션 사이에 일시적인 관계를 설정 해야 한다.

### 콜백 지옥에 빠짐

- 콜백함수는 대량 데이터를 순차적으로 로드할 경우 확장하기 어렵고 `콜백 지옥`에 빠지기 쉽다.
- 콜백의 주용도 : 처리시간이 오래 걸리는 프로세스를 기다리는 도중 UI를 차단하지 않는 것.
- `제어의 역전`이 일어남 : 함수형 프로그래밍의 설계 사상과 배치됨
- 함수형 프로그램의 함수는 서로 독립적이며 값을 호출하여 늑시 반환해야한다.

### 동기/비동기 코드가 호환되지 않음

중첩된 콜백 함수는 읽기도 어렵지만 자기 스코프 및 자신이 중첩된 함수의 변수 스코프를 감싼 클로저를 만듭니다.
함수가 어떤일을 달성하기 위해 자신의 외부 변수에 직접 접근해야 할 경우에만 의미가 있습니다.
내부 콜백함수는 불필요한 외부 데이터를 참조하는 레퍼런스를 고스란히 간직하고 있습니다. 이런 코드를 연속체 전달 스타일로 바꾸어 개설할 수 있습니다.

내부콜백 함수를 개별 함수 또는 람다 표현식으로 나눈다.

- CPS 는 비차단 프로그램의 조각들을 개별 컴포넌트로 분리하기 위한 프로그래밍 스타일입이다.
- 여기서 콜백 함수는 현재 연속체라고 부르며 함수 자체를 호출자에게 반환값으로 돌려줍니다.
- CPS 코딩은 코드에 잔존하는 일시적 의존 관계를 버리고, 비동기 흐름을 선형적인 함수 평가 형태로 변화시킨다.

## 8.2 비동기 로직을 프라미스로 일급화

- 함수형 프로그램이 가지는 특성

  - 합성과 무인수 프로그래밍을 이용한다.
  - 중첩된 구조 => 선형적으로 흐르게 눌러 편다.
  - 여러 콜백 대신, 단일 함수로 에러 처리 로직을 통합하여 코드 흐름을 원활하게 할 수 있다.
  - 프라미스는 오래 걸리는 계산을 모나드로 감싸는 것이다.

- 기존 모나드와는 다르게 프라미스는 오래 걸리는 계산이 끝날때까지 기다렸다가 미리 매핑한 함수를 실행한다.

  - 반환값이 불확실한 함수를 Maybe, Either 모나드로 감쌌듯이,
  - 프라미스는 데이터(응답)를 받을 때까지 기다린다.
  - 프라미스는 중간에 실패하더라도 Maybe, Either 처럼 비슷하게 에러 처리 로직을 통합하여 대응한다.

- 프라미스의 상태
  - 보류
  - 이룸
  - 버림
  - 귀결

다른 객체에 데이터가 당도했음을 통보하고, 처리 도중 에러가 나면
미리 등록한 실패 콜백 함수를 호출한다.

비동기 작업을 프라미스로 감싸고 이룸/버림 두 콜백을 받는 과정, 프라미스는 처음에 보류 상태로 출발해서 이룸 아니면 버림 상태가 바뀌고, 귀결 상태로 이동하기 전, 각각
resolve 또는 reject 함수를 호출한다.

### 미래의 메서드 체인

프라미스 객체는 then 포함한다. 프라미스에 보관된 반환값에 연산을 수행하고 다시 프라미스 형태로 되돌리는 메서드입니다.
Maybe.map(f) 처럼 Promise.then(f) 는 데이터 변환 작업을 서로 체이닝하고 여러 함수를 제때 모아 함수 사이의 일시적인 결합을 추상하기도 한다.
then 메서드의 두 인수는 성공, 실패 콜백이었다.

- 비동기 호출을 중첩하는 대신 then 으로 체이닝하고, 비동기 코드를 프라미스 모나드로 추상화합니다.
- 에러 처리 로직을 제일 마지막의 catchall 함수에 몰아 넣습니다.
- 데이터를 IO 모나드에 승급하여 부수효과 없이 DOM 에 표시합니다.

## 8.3 느긋한 데이터 생성

- 제너레이터(`generator`)로 데이터를 생성하는 방법에 대한 규칙을 설정할 수 있다.
  - 모양 : function\*
  - yield: 함수 밖으로 잠시 나갔다가 자신의 보관된(전체 지역 변수가 바인딩 된) 콘텍스트를 찾아 다시 돌아오는 독특함이 있다.
  - 일반 호출과는 달라서, 제너레이터 함수의 실행 콘텍스트는 중단했다가도, 언제든 재개할 수 있어서 제너레이터로 다시 들어올 수 있다.

### 제너레이터와 재귀

- 제너레이터도 다른 제너레이터를 호출할 수 있다.
- 제너레이터는 for..of 루프문으로 반복할 수 있기 때문에 다른 제너레이터에게 **위임하는 것(?)**은 마치 두 컬렉션을 병합한 전체 컬렉션을 반복하는 것과 비슷하다.

### 이터레이터 프로토콜

- 이터레이터 : (배열 등의) 자료구조를 루프로 반복할 수 있도록 하는 것.
- 제너레이터 함수는 내부적으로 이터레이터 프로토콜에 따라 yield 키워드로 값을 반환하는 next() 메서드가 구현된 Generator 객체를 반환한다.
  - done: 제일 마지막에 이터레이터가 전달되면 true, 그외에는 false, false는 이터레이터가 아직 도중에 다른 값을 생산할 수 있음을 의미한다.
  - value: 이터레이터가 반환한 값

## 8.4 RxJS를 응용한 함수형 프로그래밍

- RxJS 리액티브 라이브러리

  - 비동기 프로그램과 이벤트 기반 프로그램을 우아하게 엮음.
  - 함수형 프라미스 기반의 예제와 비슷한 방식으로 작동하지만, 더 높은 수준의 추상화를 제공하여 더 강력한 연산을 제공한다.

### 옵저버블 순차열로서의 데이터

- 옵저버블(`observable`) : 구독(`subscribe`)가 가능한 모든 객체를 가리킨다.
- (예시 1)

  ```javascript

  Rx.Observable.range(1,3)
    .subscribe( //subscribe 메서드는 3개의 콜백 함수를 받는다.
      x => console.log(`다음: ${x}`), //순차열의 각 원소를 처리하는 함수
      err => console.log(`에러 : ${err}`), //예외가 나서 중단시키는 함수
      () => console.log('완료!'); //얌전히 끝내는 함수
    );
  ```

- (결과 1)

  ```javascript
  다음: 1
  다음: 2
  다음: 3
  완료! //스트림 완료!
  ```

- (예시 2)

  ```javascript
  const squares = Rx.Observable.wrap(function*(n) {
    for (let i = 1; i <= n; i++) {
      return yield Observable.just(i * i);
    }
  });

  squares(3).subscribe(x => console.log(`다음: ${x}`));
  ```

- (결과 2)

  ```javascript
  다음: 1;
  다음: 4;
  다음: 9;
  ```

- 결론
  - 어떤 자료형이라도 Rx.Observable을 이용해서 스트림을 바꿀 수 있다. => 다루는 방식이 같다.
  - 어떤 옵저버블 객체라도 감싸거나 승급하면 값에 상이한 함수를 매핑/적용해서 원하는 출력을 얻도록 변환할 수 있다. 모나드이다.

### 함수형 리액티브 프로그래밍

Rx.Observable 객체는 함수형과 리액티브 두 프로그래밍을 하나로 묶는다.
이 객체는 map, of, join 처럼 최소한의 모나드 인터페이스에 해당하는 구현체와 스트림 조작에 특화된 메서드을 거느린다.

```js
Rx.Observable.of(1, 2, 3, 4, 5)
  .filter(x => x % 2 === 0)
  .map(x => x * x)
  .subscribe(x => console.log(x));
```

- 리액티브 프로그래밍과 함수형 프로그래밍의 관련성

  - 리액티브 프로그래밍 관련 문서가 대부분 함수형 프로그래밍 기법을 설명하는 것으로 시작한다.
  - 스트림을 이용 => 코드를 선언적으로 연산 체이닝하는 형태로 작성한다.
  - 리액티브 프로그래밍 / 함수형 프로그래밍 / 함수형 + 리액티브 프로그래밍

- Rx.Observable을 추상화 계층으로 두는 이유
  - 프라미스로 함수형과 비동기 함수의 부조화를 해결했던 것처럼 이벤트와 함수형 두 세계를 접목하기 위해서.

### RxJS와 프라미스

- 함수형 리액티브 프로그래밍은 프로그램의 추상화 수준을 높여 이벤트를 논리적으로 독립된 단위로 다룰 수 있게 한다.

> 오늘의 문제
