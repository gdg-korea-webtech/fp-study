> # 문제풀이
>
> [js-validation](https://stackblitz.com/edit/fp-study-week-06-js-validation)

# Chapter 6. 빈틈없는 코드 만들기

### wrote by. robin

- 이전까지의 내용 요약
  - 주로 함수형 프로그래밍이 코드를 쉽게 이해하고 관리할 수 있게 한다는 사실에 대한 서술이었다.
- 이번 파트의 내용
  - 함수형 코드로 작성한 다음, 제대로 작동하는지 확인하는 방법 => 테스트 코드 작성
  - 함수형 코드는 다른 패러다임의 코드와 비교했을 때 테스트하기 좋은 점에 대해서 설명할 예정이다.

## 6.1 함수형 프로그래밍과 단위 테스트

#### 테스트의 분류와 함수형 프로그래밍의 영향력 사이의 상관관계

- 결론 : 함수형 프로그래밍의 영향력은 인수 테스트에서 단위 테스트 쪽으로 갈수록 확대된다. => 함수와 모듈의 설계, 그리고 그 구성 요소의 통합에 집중하는 소프트웨어 개발 패러다임이니까
- 단위 테스트(`unit test`) : 코드 베이스 하위 계층에 영향을 미침
- 통합 테스트(`integration test`) : 코드에 존재하는 여러 모듈을 합리적으로 통합할 수 있음
- 인수 테스트(`acceptance test`) : 소프트웨어 패러다임과 무관함

## 6.2 명령형 프로그램 테스트의 어려움

### 테스트 하기 어려운 이유

- 데이터 흐름을 보관하고 계산을 조합하는 대신, 전역 상태와 변이에 의존하기 때문이다.
- 단위 테스트 설계의 주요 원칙 중 하나가 `격리(isolation)`이다. 다른 데이터나 주변 테스트에 상관없이 실행되어야 한다. 부수효과를 유발하는 코드는 기능을 테스트할 때 제약 사항이 된다.

### 이유1) 작업을 식별하고 분해하기 어려움

- 단위 테스트는 설계상 어플리케이션의 가장 작은 부분을 테스트 한다.
- 처음부터 모듈 단위(`unit of modularity`)로 설계하지 않았다면 명령형 프로그램은 테스트 하기 어렵다.
- 함수의 테스트 가능 범위를 넓히려면, 순수한 부분과 불순한 부분이 구분되고, 느슨하게 결합된 컴포넌트로 함수를 나눌 방법을 궁리해야 한다.

### 이유2) 공유 자원에 의존하면 들쭉날쭉한 결과가 나옴

- 외부의 값(전역변수)에 영향을 받는 경우 => 부수효과를 지닌 함수는 평가 순서에 따라 결과가 달라질 수 있다.

### 이유3) 평가 순서를 미리 정해야 함

- 단위 테스트 설계 원칙

  - `격리의 원칙 - 격리(isolation)` : 단위 테스트는 실행 순서를 바꿔도 결과가 달라져서는 안된다.
  - `일관성의 원칙 - 결합성(commutative)` : 실행 순서를 바꿔도 결과가 달라지면 안된다.

- 함수형 사고방식/함수형 프로그래밍이 테스트에 유용하다.

## 6.3 함수형 코드를 테스트

### 함수를 블랙박스처럼 취급

- 함수를 `블랙박스`로 취급한다(= 주어진 입력에 맞는 출력을 내는가?)
  - 부수효과가 없고, 참조투명하다.
  - 결과가 예측가능하다.

### 제어 흐름 대신 비즈니스 로직에 집중

- 문제를 더 작은 부분으로 나누는 것 = 작업이 단순한 함수들로 분해하는 것
- 주요 프로그램 로직에 대한 개별 함수만 테스트 할 수 있다.

### 모나드 격리를 통해 순수/불순 코드를 분리

- 프로그램은 순수한 부분과 불순한 부분을 모두 가진다.
- IO 외에도 Maybe, Either같은 모나드를 써서 도중에 실패하더라도 계속 실행 가능한 프로그램을 작성할 수 있다.
- **Q.대부분의 부수효과는 제어가 가능하지만, DOM 읽기/쓰기에 대한 테스트도 잘 격리되어 있고 반복 가능할까?**

  - Ex.

  ```javascript
  const showStudent = R.compose(
    map(append("#student-info")),
    liftIO,
    getOrElse("student not found"),
    map(csv),
    map(R.props(["ssn", "firstname", "lastname"])),
    chain(findStudent),
    chain(checkLengthSsn),
    lift(cleanInput)
  );
  ```

  - 명령형 버전을 잘게 부분 후, 합성 및 모나드를 사용해서 재조립했다.
  - 테스트 가능한 영역(순수 함수)
    - cleanInput
    - checkLengthSsn
    - csv
  - 불순 함수
    - findStudent (하지만 테스트 가능)
    - append (믿음성 있는 테스트 불가)

### 외부 디펜던시를 모의

- `모의(mocking)

  - **함수의 외부 의존을 제어/단언 가능한 방향으로 모방하는 데 쓰인다.(?)**
  - 함수와 상호작용하는 객체가 해야 할 일을 미리 정의해야 한다.
  - 모의 객체는 기대를 충족하지 않을 경우 테스트를 불합격 처리한다.

## 6.4 속성 기반 테스트로 명세 담기

- 훌륭한 명세는 사례에 기반을 두지 않는다.
- 좋은 명세란? 일반적이고 보편적인 것.
  - 어느 특정 시점의 시스템 상태에 의존하지 않는다. => 부수효과를 유발하거나 주변 콘텍스트를 추측하지 않는다.
  - 명세가 참조 투명하면, 함수가 할 일이 명확해진다. => 일관되게 작동하며, 입력이 분명하므로 테스트를 자동화하기 쉽다.

> ### JSCheck 라이브러리 소개

## 6.5 코드 실행률로 효율 측정

`코드 실행률(%)` = `실제로 실행된 코드 라인 수` / `전체 코드 라인 수`

### 함수형 코드 테스트의 효율 측정 - 입력이 올바른 경우

- 명령형 : 에러 처리 로직을 건너뛰었기 때문에 실행률이 75~80% 정도면 우수한 수준이다.
- 함수형 : 똑같은 정상 경로인데, 실행률 100%이다.

### 함수형 코드 테스트의 효율 측정 - 입력이 잘못된 경우

- null처럼 잘못된 입력값을 넣고 두 프로그램(명령형/함수형)을 실행했다.
- 명령형 : if-else 블록 때문에 제어 흐름이 여러 갈래로 흩어진다. => 함수의 복잡도 증가
- 함수형 : 잘못된 입력을 직접 건드리는 로직을 건너뛴다.

### 코드를 복잡하게 만드는 요소

- 불리언 조건에 따라 제어 흐름이 분리되는 경우(if-else 블록)
- 외부 요인에 따른 조건별로 분리하는 경우 : 부수효과에 따라 코드가 흘러가는 경우가 달라짐
- 결론
  - 조건 블록이 늘어나고 중첩 수준이 깊어지면 점점 함수를 테스트하기 어렵다.
  - 최대한 함수를 간결하게 유지하기 위해서 람다 표현식으로 축약하고 합성과 모나드로 조합해서 쓰자.

### 함수형 코드의 복잡도 측정

- 순환 복잡도(`Cryclomatic Complexity`)
  - 노드는 더 이상 나눌 수 없는 코드 블록이다.
  - 코드 블록 두 개가 있고 2번 블록이 1번 블록 이후에 실행 가능할 때, 방향성 있는 간선으로 연결한다.
  - `M(복잡도)` = `E(간선 갯수)` - `N(노드나 블록 갯수)` + `P(출구 잇는 노드의 갯수)`

> 오늘의 문제
> [링크](https://stackblitz.com/edit/fp-study-week-07)
>
> 테스트하기 좋게 코드를 리팩토링하고, 다음 테스트 케이스를 검증하세요.
>
> case 1)
>
> - input : 0 +=
> - output: 0
>
> case 2)
>
> - input : 3 + 4 + 3 =
> - output: 10
>
> case 3)
>
> - input : -3 + -4 + -3 =
> - output: -10
>
> case 4)
>
> - input : -3 +3 =
> - output: 0
