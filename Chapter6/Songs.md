# Part3 함수형 스킬 갈고닦기
## Chapter6 빈틈없는 코드 만들기

date : 19.04.01

---

>단위 테스트의 목적은 코드가 개발 명세를 충족하는지 확인하고 코드가 실패하는 모든 경계 조건 주변에 담장을 치는 것

**테스트에서 명령형 코드의 문제**

- 부수효과를 내므로 시스템의 전역 상태를 잘못 넘겨짚게 됨
- 이로 인해 무수한 에러에 취약할 수 밖에 없는 한계
- 테스트 간의 독립적인 실행 불가
- 테스트를 미루거나 그냥 넘어가게 됨

## 6.1 함수형 프로그래밍과 단위 테스트

함수형 프로그래밍의 핵심은 함수(코드를 모듈화하는 단위) 간의 소통, **함수와 모듈의 설계**, 그 **구성 요소의 통합**에 집중하는 개발 패러다임이므로 코드에 미치는 FP의 영향력은 인수 테스트(꼭대기)에서 단위 테스트(바닥) 쪽으로 갈수록 확대

**코드에 미치는 영향력**

인수 | 통합 | **단위**
--- | --- | ---
없음 | 조금 있음 | **아주 큼**
인수 테스트는 소프트웨어 패러다임과 무관 | FP는 코드에 존재하는 여러 모듈을 합리적으로 통합 가능 | FP는 코드베이스 하위 계층에 영향을 미침




## 6.2 명령형 프로그램 테스트의 어려움

단위 테스트 설계의 주요 원칙 중 하나는 **격리**, 다른 데이터나 주변 테스트에 상관없이 실행되어야 함

명령형 테스트는 전역 상태와 변이에 의존하기 때문에 테스트하기 어려움, 부수효과를 유발하는 코드로 기능을 테스트할 때 심한 제약을 받게 됨

- 식별은 물론 간단한 작업으로 분해하기도 어려움
- 결과를 들쭉날쭉하게 만드는 공유 자원에 의존
- 반드시 평가 순서를 미리 정해야 함

### 6.2.1 작업을 식별하고 분해하기 어려움

단위 테스트는 설계상 애플리케이션의 **가장 작은 부분을 테스트** 하므로 절차적 프로그램에서 **모듈 단위**를 식별하기란 어려움

**모듈 단위** : 비즈니스 로직을 캡슐화한 함수

그렇기 때문에 합성을 통해 조립 가능하고 테스트 가능한 비즈니스 단위로 나누자.

### 6.2.2 공유 자원에 의존하면 들쭉날쭉한 결과가 나옴

**안정된 테스트** 
- 다른 테스트와 독립적으로 작동해야함
- 시스템 상태는 정확히 테스트 실행 전 상태로 유지 되어야 함

명령형 함수 테스트시, 테스트에 새 테스트를 추가하면 전혀 무관한 다른 테스트가 실패하는 사례가 나옴

>명령형 함수 테스트
```js
//0에서 1만큼 증가시킨 결과가 정말 1인지 확인
// 명령형
var count = 0;
function addCount(){
  return ++count
}

// 함수형
function addCountFp (num){
  return num += 1
}

QUnit.test( "test addCount", function( assert ) {
  // 명령형 테스트
  assert.equal( addCount(0), 1, "0 + 1 = 1" );
  assert.equal( addCount(0), 1, "전역변수가 바뀐상태라 실패!" );
  assert.equal( addCount(2), 3, "2 + 1 = 3, 두번 테스트를 돌면서 전역변수가 2로 바뀐상태, 테스트 값을 억지로 끼워 맞추면 성공" );
  assert.equal( addCount(0), 1, "전역변수가 바뀐상태라 실패!" );

  // 함수형 테스트
  assert.equal( addCountFp(-2), -1, "-2 + 1 = -1" );
  assert.equal( addCountFp(0), 1, "0 + 1 = 0" );
  assert.equal( addCountFp(-1), 0, "-1 + 1 = 0" );
  assert.equal( addCountFp(1), 2, "1 + 1 = 2" );
  assert.equal( addCountFp(2), 3, "2 + 1 = 3" );
});
```

[Qunit](https://stackblitz.com/edit/qunit-test1)


실행 횟수에 상관없이 결과가 같아야 하지만 **전역 변수에 의존**하는 함수는 외부 데이터를 읽어 수정하므로 결과가 계속 바뀌어 **단위 테스트 반복 불가**

- 첫 번째 반복 시 : 외부 변수 `count`값이 바뀜
- 두 번째 반복 시 : 바뀌어버린 전역 변수 값을 단언할 때 실패

### 6.2.3 평가 순서를 미리 정해야 함

단위 테스트는 일관성 차원에서 **결합적** 이어야 함 (순서를 바꿔도 결과가 달려져선 안됨)

부수효과를 지닌 코드는 순서를 조금만 바꿔도 테스트가 실패할 가능성이 높음

테스트에 유용한 함수형으로 코딩하자

## 6.3 함수형 코드를 테스트

**장점**

- 함수를 **블랙박스**처럼 취급
- 제어 흐름 대신 **비즈니스 로직**에 집중
- **모나드 격리**를 통해 순수한 부분과 불순한 부분을 분리
- 외부 디펜던시를 모의

### 6.3.1 함수를 블랙박스처럼 취급

- 다른 부분에 구애받지 않고 느슨하게 입력값을 결합하는 함수를 **독립적**으로 작성
- 부수효과가 없고 참조 투명 -> 여러번 실행하더라도 **결과가 동일**
- **예측 가능한** 테스트를 작성 할수 있음

### 6.3.2 제어 흐름 대신 비즈니스 로직에 집중

문제를 더 작은 부분으로 나누고 분해된 함수를 서로 조합하여 작업하면 프로그램 로직을 형성하는 개별 함수를 테스트하기 좋음


### 6.3.3 모나드 격리를 통해 순수/불순 코드를 분리

잘게 부순 다음 합성 및 모나드를 이용해 재조립해서 테스트 가능한 영역을 늘리고 불순함 코드에서 순수함수를 분리

### 6.3.4 외부 디펜던시를 모의

**모의** : 함수의 외부 디펜던시를 제어/단언 가능한 방향으로 모방하는 데 많이 쓰임

- 부수효과를 다루기 좋은 테스트 기법
- 조건을 충족하지 않을 경우 테스트를 부합격 처리
- 작성한 함수와 상호작용하는 객체가 해야 할 일을 미리 정의
- 외부 자원을 마음대로 조정 가능하여 예측 가능하고 일관된 방향으로 테스트 진행 가능

함수형 코드가 테스트성이 좋은 이유는 **참조 투명성**

**단언**이란 그 자체가 참조 투명성이 항상 유효한지 검증하는 행위


## 6.4 속성 기반 테스트로 명세 담기

단위 테스트는 함수의 런타임 명세를 담고 문서화하는 용도로 사용 가능

명세가 참조 투명하면 함수가 할 일이 더 잘 파악되고, 충족되어야 할 입력 조건이 명확해짐

참조 투명한 함수는 일관되게 작동하며 입력 매개변수가 분명하므로 극한 케이스까지 점검할 수 있게 테스트 자동화가 쉬움 -> **속성 기반 테스트** 실천 가능

**속성 기반 테스트** 
- 함수에 어떤 입력을 넣으면 어떤 출력이 나와야 맞는지 성명
- 프로그램 리팩터링 시 새로 추가한 코드가 오류를 일으키지 않는지 검증
- 프로그램의 진화과정을 제어/관리하는 용도로도 쓰임
  
[`JSCheeck`](http://www.jscheck.org/)

```js
JSC.clame(이름, 술어, 특정자, 분류자)
```

- 이름 : 주장을 서술
- 술어 : 주장을 만족하면 true, 그렇지 않으면 false 결론을 내는 함수
- 특정자 : 입력 매개변수의 형식과 무작위 자료 집합의 생성 기준을 서술한 배열
- 분류자 (선택사항) : 해당 없음 케이스를 버릴 때 쓰려고 각 테스트 케이스에 붙이는 함수


## 6.5 코드 실행률로 효율 측정

**블랭킷JS** 자바스크립트용 코드 실행률 도구로 실행된 코드 라인 수의 비율(%)로 계산

- 1.소스 파일을 읽는다
- 2.추적기 라인을 추가해서 코드를 장착
- 3.테스트 실행기에 걸어 상세 실행률 정보를 산출

함수형 코드가 명령형 코드보다 테스트성이 월등히 높다

### 6.5.1 함수형 코드 테스트의 효율 측정

함수형 코드는 입력이 올바른 경우 전체 코드 영역을 무작정 건너뛰지 않고 입력값에 의존하는 함수들만 건너뜀

### 6.5.2 함수형 코드의 복잡도 측정

**순환 복잡도** : 함수의 선형 독립적인 경로의 개수를 측정하기 위한 정량적인 소프트웨어 지표

`M = E - N + P`

- M : 프로그램의 복잡도
- E : 간선 개수
- N : 노드나 블록의 개수
- P : 출구 있는 노드의 개수

함수형 프로그래밍에서는 루프나 조건문 대신 고계함수, 함수 조합기 등의 추상화 장치를 많이 사용하므로 순환 복잡도 측정은 훨씬 간단

노드와 간선은 확실히 줄고 함수 내 모든 경로는 선형 독립적으로 바뀌고 **순환 복잡도를 계산하면 대개 1에 가까운 값이 나옴**

> 명령형/함수형 프로그램에서 추론 가능한 다른 복잡도 관련 지표

비교 | 명령형 | **함수형**
--- | --- | ---
순환 복잡도 | 4 | 1
순환 복잡 밀도 | 29% | 3%
유지보수성 지수 | 100 | 148

**순환 복잡 밀도** : 순환 복잡도 수치를 명령형 코드 라인 수 대비 비율(%)로 환산한 지표 (함수형 프로그램이 월등히 작음)

- 프로그램의 테스트성은 얼마나 프로그램을 잘 설계했느냐에 정확히 비례
- 코드를 모듈화할수록 테스트도 쉬움
- 함수형 프로그램은 함수라는 단위 자체에 이미 모듈성을 내포하고 있어 테스트하기 좋음


---

### week5 문제 풀이

[validation](https://stackblitz.com/edit/js-validation-2)


### week6 문제 
