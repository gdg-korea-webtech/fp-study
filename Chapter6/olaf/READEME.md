# Chap 05. 함수형 프로그래밍 스터디

## 빈틉없는 코드 만들기

> 담장이 튼튼해야 이웃 사이가 좋지요.

단위 테스트의 목적은 코드가 개발 명세를 충족하는지 확인하고 코드가 실패하는 모든 경계 조건 주변에 담장을 치는 것 입니다.

- 명령형 코드는 부수효과를 내기 때문에 시스템 전역 상태를 넘겨짚게 되고, 에러에 취약할 수 밖에 없는 한계가 있습니다
- 함수형 설계는 외부 디펜던시를 제거하고 예측 가능한 함수를 작성하는 등 바람직한 테스트를 작성하기 좋습니다.

### 함수형 프로그래밍과 단위 테스트

테스트는 단위 테스트, 통합 테스트, 인수 테스트(사용자가 기대하는 부분과 얼마나 부합한가) 세 가지로 분류됩니다.

### 명령형 프로그램 테스트의 어려움

단위 테스트 설계의 주요 원칙 중 하나는 "격리" 입니다. 부수 효과를 유발하는 코드는 기능을 테스트할 때 심한 제약을 받습니다.

명령형 코드의 문제점은 다음과 같습니다.

- 식별은 물론 간단한 작업으로 분해하기 어렵습니다.
- 결과를 들쭉날쭉하게 만드는 공유 자원에 의존합니다.
- 평가 순서를 미리 정해야 합니다.

#### 작업을 식별하고 분해하기 어려움

단위 테스트는 설계상 어플리케이션의 가장 작은 부분을 테스트합니다. 거대한 모놀리틱 프로그램은 직관적으로 알기 쉽게 나눌 방법이 마땅치 않아 모듈 단위를 식별하기 어렵습니다.

```js
function showSheet(ssn) {
  // 검증
  if (ssn !== null) {
    throw Error("");
  }

  const student = db.get(ssn); // 조회

  document.querySelector(""); // DOM IO
}
```

위의 코드는 관심가사 제각각인 비지니스 로직이 하나의 함수 안에서 결합되어 있습니다. 합성을 통해 이들을 조립 가능한 단위로 나눌 수 있습니다.
불순한 코드 DOM, 저장소 등의 외부 자원을 읽고 쓰는 도중 부수효과를 일으킬 수 있어 테스트하기 어렵습니다.

#### 공유 자원에 의존하면 들쭉날쭉한 결과가 나옴

안정된 테스트라면 나머지 다른 테스트와 독립적으로 그 자체로 돌아가야 합니다. 각 단위 테스트는 독립된 환경에서 작동해야 하며, 시스템 상태는 테스트 실행 전 상태로 유지되어야 합니다.
이러한 규칙을 위반한 테스트는 동일한 결과를 일관되게 낼 수 없습니다.

```js
let count = 0;
function increment() {
  return (count += 1);
}
// 성공
test("increment 는 0 에서 1 만큼 증가시킨다.", () => {
  expect(increment()).toBe(1);
});

// 실패
test("increment 는 0 에서 1 만큼 증가시킨다.", () => {
  expect(increment()).toBe(1);
});
```

#### 평가 순서를 미리 정해야함

단위 테스트는 일관성 차원에서 결합적이어야 합니다. 실행 순서를 바꾸더라도 결과가 달라져서는 안됩니다.
시스템의 전역 상태를 바꾸는 부수효과를 가지고 있다면 순서를 뒤섞으면 상태에 관한 예측은 모두 빗나갑니다.
함수형 사고방식은 테스트를 안정적으로 구축하는데 도움이 됩니다.

### 함수형 코드를 테스트

FP의 모든 함수는 입력 매개변수가 명확히 정의되어 있으므로 여러 가지 경계 조건 집합을 제공하여 코드를 살피는 일은 어렵지 않습니다.
함수형 프로그래밍에서 모든 함수는 단순명료 해야하고, 불순한 코드는 모나드로 감쌀 수 있었습니다.
또 map, reduce, filter, 재귀 등의 고계 연산과 부수효과 없는 라이브러리를 이용해서 해결했습니다.

#### 함수를 블랙박스처럼 취급

함수형 프로그래밍에서는 다른 부분에 구애받지 않고 느슨하게 입력값을 결합하는 함수를 독립적으로 작성합니다.
이러한 함수는 부수효과가 없고 참조 투명합니다.

```js
function increment2(num) {
  return (num += 1);
}

test("increment2 는 받은 숫자에 1 만큼 증가시킨다.", () => {
  expect(increment2(10)).toBe(11);
});

test("increment2 는 받은 숫자에 1 만큼 증가시킨다.", () => {
  expect(increment2(1)).toBe(2);
});
```

#### 제어 흐름 대신 비즈니스 로직에 집중

라이브러리와 함수조합기를 이용한다면 설계와 분해 과정에 쏟을 시간을 절약할 수 있습니다.

```js
const R = require("ramda");

function fork(join, func1, func2) {
  return function(value) {
    return join(func1(value), func2(value));
  };
}

function toLetterGrade(grade) {
  if (grade >= 90) return "A";
  if (grade >= 80) return "B";
  if (grade >= 70) return "C";
  if (grade >= 60) return "D";
  return "F";
}

module.exports = R.compose(
  toLetterGrade,
  fork(R.divide, R.sum, R.length)
);
```

위의 테스트를 순서를 바꾸거나 몇번을 실행하더라도 참조 투명한 함수이기 때문에 결과는 같습니다.

#### 모나드 격리를 통해 순수/불순 코드를 분리

모든 프로그램은 대부분 순수한 부분과 불순한 분을 가지고 있습니다. 모나드를 이용하면 대부분의 부수효과는 제어가 가능하지만, DOM 읽기/쓰기가 필요한 자바스크립트 코드의 테스트가 잘 격리되어 있다고 장담할 수 있을까요 ?

```js
const showStudent = R.compose(
  map(append("#student-info")),
  liftIO,
  getOrElse("학생을 찾을 수 없습니다"),
  map(csv),
  map(R.props(["ssn", "firstname", "lastname"])),
  chain(findStudent),
  chain(checkLengthSsn),
  lift(cleanInput)
);
```

위의 함수는 명령형 버전을 잘게 부순 다음 합성 및 모나드를 이용하여 재조립하는 것을 볼 수 있습니다.
불순한 코드에서 순수함수를 뗴어낼 수 있습니다.

#### 외부 디펜던시를 모의

모의는 함수의 외부 디펜던시를 제어/단언 가능한 방향으로 모방하는데 많이 쓰입니다.
부수효과를 다루기 좋은 테스트 기법입니다.

모의 컨텍스트를 이용하면 몇 번 호출했는지, 어떤 인수를 받았는지 반환했는지 기대 동작을 다양하게 지정할 수 있습니다.

#### 속성 기반 테스트로 명세 담기

단위 테스트는 함수의 런타임 명세를 담고 문서화하는 용도로 사용할 수 있습니다.

```js
test("computeAverageGrade 는 받은 점수들을 계산하여 학점을 계산한다", () => {
  expect(computeAverageGrade([80, 90, 100])).toBe("A");
});
```

위의 테스트를 다음과 같이 문서화 할 수 있습니다

- 학생의 평균 성적이 90 점 이상이면 A 학점을 받는다.

명령형 조건 분기가 제거된 문장이 훨씬 완성도가 높습니다.

- 평균이 90점 이상인 학생만 A 학점을 준다.

좋은 명세는 부수효과를 유발하거나 주변 컨텍스트를 섣불리 추측하지 않습니다.

JSCheck 구성 요소

- 이름: 주장을 서술
- 술어: 주장을 만족하면 true, 그렇지 않으면 false 를 내는 함수
- 특정자: 입력 매개변수의 형식과 무작위 자료 집합의 생성 기준을 서술한 배열
- 분류자: 케이스를 버릴 때 쓰려고 각 테스트 케이스에 붙이는 함수

### 코드 실행률로 효율 측정

단위 테스트의 효율은 대상 함수에 관한 테스트 코드 실행률을 나타내기 때문에 도구 없이 측정하기는 어렵습니다.
코드 실행률은 품질 지표는 아니지만, 함수를 테스트한 정도를 표시하므로 품질 향상과 연관성이 있습니다.

#### 함수형 코드의 복잡도 측정

프로그램의 복잡도를 측정하려면 제어의 흐름을 파악하여야 합니다.
외부 요인에 따른 조건별 분기, 부수효과에 따라 코드 흘러가는 경로가 달라지면 프로세스가 복잡해집니다.

순환 복잡도는 함수의 선형 독립적인 경로의 개수를 측정하기 위한 정량적인 소프트웨어 지표입니다.
어떤 함수를 통과하는 모든 경로를 확실히 테스트 하려면 경계 조건을 확인하면 된다는 발상에서 비롯된 개념입니다.
순환 복잡도는 노드와 간선이 등장하는 간단한 그래프를 기반으로 합니다.

- 노드는 더 이상 나눌 수 없는 코드 블록입니다.
- 코드 블록 두 개가 있고 2 번 블록이 1 번 블록 이후에 실행 가능할 때 방향성 있는 간선으로 간주합니다.

순환 복잡도에 영향을 미치는 인자는 무엇일까요

- E: 간선의 갯수
- N: 노드나 블록의 개수
- P: 출구 있는 노드의 개수

조건 블록은 프로그램의 제어 흐름을 두 갈래의 선형 독립적 경로로 분할하기 때문에 가장 복잡도를 높이는 요인입니다.

함수형 프러그래밍에서는 가급적 루프나 조건문 대신 고계함수, 함수 조합기 등의 추상화 장치를 많이 쓰기 때문에 순환 복잡도 측정은 훨씬 간단합니다.
노드와 간선이 줄고 함수 내 모든 경로는 선형 독립적으로 변경되고 순환 복잡도를 계산하였을때 1에 가까운 값이 나옵니다.

순환 복잡 밀도란 순환 복잡도 수치를 명령형 코드 라인 수 대비 비율로 환산한 지표입니다.

### 마치며

- 함수들을 결합하는 추상화로 프로그램을 모듈화 할 수 있습니다.
- 순수함수에 기반을 두 모듈적인 코드는 테스트기 쉽고 속성 기반 테스트처럼 더 엄격한 테스트 방법론을 적용할 수 있습니다.
- 제어 흐름이 직관적이어야 합니다.
- 제어 흐름이 단순해지면 복잡도가 줄어듭니다. 복잡도는 지표를 통해 정량적으로 측정할 수 있습니다.
