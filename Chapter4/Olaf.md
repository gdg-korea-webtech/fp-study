# Chap 04. 함수형 프로그래밍 스터디

> 잘 작동하는 복잡한 시스템은 십중팔구 잘 작동했던 단순한 시스템에서 진화한 경우가 많다.

단어를 대문자에서 소문자로 바꾸고 중복은 제거한 다음 단어들을 정렬하는 순차적인 과정입니다.
아래와 같이 입/출력을 명료한 규약에 맞게 서술하고 작은 프로그램들을 서로 이어 붙여 복잡한 작업을 수행할 수 있습니다.

```bash
tr 'A-Z' 'a-z' < word.in | uniq | sort
```

대규모 소프트웨어 매우 중요한 특성중의 하나인 `모듈성`은 프로그램을 더 작고 독립적인 부분으로 나눌 수 있습니다. 생산성을 높일 뿐만 아니라 코드의 유지보수성 및 가독성을 향상시키는데 도움이됩니다.

## 메서드 체인 대 함수 파이프라인

파이프라이닝은 함수를 연결하는 또 다른 기법입니다. 입력과 출력을 기준으로 서술하는 것에 유용합니다.

함수형 커뮤니티에서는 하스켈 언어 표기법을 많이 사용합니다.

```text
<함수명> :: <입력형식> -> <단일 출력 형식>
```

문자열을 받아 불리언을 반환하는 isEmpty 함수는 아래와 같이 표현합니다.

```text
// isEmpty :: String -> Boolean
const isEmpty = s => !s || !s.trim()
```

함수 체이닝과 파이프라이닝을 이해하려면 함수를 형식 간의 매핑으로 바라봐야합니다.

- 메서드를 체이닝 (단단한 결합, 제한된 표현성)
- 함수 파이프라인을 배열 (느슨한 결합, 유연성)

## 메서드를 여럿 체이닝

함수를 서로 체이닝하면 새로운 자료구조를 만드는데 명령형 코드에 비해 구조적으로 향상됐고 가독성도 좋아졌습니다.
하지만 자신을 소유한 객체에 부자연스럽게 매여 있기 떄문에 코드의 표현성에 제약을 받습니다.

그래서 필요한것이 함수 파이프라이닝입니다.

### 함수를 파이프라인에 나열

메서드 체이닝의 한계에 벗어나 어떤 함수라도 유연하게 결합할 수 있습니다. `파이프라인`이란 함수의 출력이 입력이 되게끔 느슨하게 배열한 방향성 함수 순차열입니다.

### 함수의 호환 요건

- 형식: 함수의 반환 형식과 수신 함수의 인수 형식이 일치해야합니다.
- 항수: 수신 함수는 앞 단계 함수가 반환한 값을 처리하기 위해 하나 이상의 매개변수를 선언해야합니다.

### 형식이 호환되는 함수

함수 파이프라인을 설계할 떄에는 한 함수가 반환하는 것과 다른 함수가 받는 것이 반드시 호환되어야합니다.
어떤 객체가 특정 형식처럼 작동하면 그 형식은 그 객체의 형식인 것입니다. 이것을 덕 타이핑 이라고합니다.

학생 SSN 을 처리하는 간단한 프로그램을 봅시다. f 와 g 형식이 있고 f의 출력과 g 의 입력의 형식이 동등하면 두 함수의 형식은 호환됩니다.

```text
trim :: String -> String   앞 뒤 공백을 제거합니다.
normalize :: String -> String  입력 문자열의 대시를 제거합니다.
```

### 함수와 항수 : 튜플

항수란 함수가 받는 인수의 개수입니다. 함수의 길이라고도 합니다.
인수가 1개인 순수함수는 단일 책임을 담당하므로 가장 단순한 함수라고 볼 수 있습니다.
우리의 목표는 함수의 인수를 가능한 한 적게 하는 것입니다.

함수형 언어는 튜플이라는 자료구조를 지원합니다. 튜플은 유한 원소를 지닌 정렬된 리스트로, 한번에 두세개 값을 묶어 (a,b,c) 와 같이 씁니다.

튜플은 형식이 다른 원소를 한데 묶어 다른 함수에 건네주는 일이 가능한 불변성 자료구조입니다.
튜플을 사용하면 함수간에 데이터를 변환할떄 다음 측면에서 유리합니다.

- 불변성: 튜플은 한번 만들어지면 나중에 내용을 못 바꿉니다.
- 임의 형식의 생성방지: 전혀 무관한 값을 연관지을 수 있습니다.
- 이형 배열의 생성방지: 형식이 다른 원소가 배열에 섞여 있으면 형식을 검사하는 방어 코드를 수반하기 떄문에 다루기가 까다롭습니다.

### 커리된 함수를 평가

커링을 이해하려면 일반 평가와 커리된 평가의 차이점을 인지해야합니다.
비커리된 일반 함수를 호출할 때 인수가 모자라도 문제 없이 실행됩니다.
a, b, c 를 호출할 때 a 값만 넣어도 b,c 는 undefined 로 자동 세팅하므로 함수는 정상적으로 실행됩니다.

이와 달리 모든 매개변수가 명시된 커리된 함수에 일부 인수만 넣어 호출하면, 함수가 실행되는게 아니라 모자란 나머지 인수가 다 채워지기를 기다리는 새로운 함수가 반환됩니다.

`커리`란 인수를 전부 받을 때까지 실행을 보류 또는 지연 시켜 단계별로 나뉜 단항 함수의 순차열로 전화하는 기법입니다.

```text
curry(f) :: ((a,b,c) -> d) -> a -> b -> c -> d
```

```js
function curry2(fn) {
  return function(f) {
    return function(s) {
      return fn(f, s);
    };
  };
}
```

### 함수 팩토리를 모방

다른 모듈의 호출자는 실제 구현부를 알지 못해도 얼마든지 함수를 불러 쓸 수 있습니다.

### 재사용 가능한 함수 템플릿 구현

재사용 가능한 함수 템플릿을 커링 기법으로 정의하면 유연성, 재사용 측면에서 좋습니다.

마지막 매개변수를 제외한 나머지 매개변수 부분을 세팅할 수 있습니다.

```js
const logError = R.curry(logger)("console", "basic");
logError("404 에러 발생");
logError("402 에러 발생");
```

### 부분적용과 매개변수 바인딩

부분적용은 함수의 일부 매개변수 값을 처음부터 고정시켜 항수가 더 작은 함수를 생성하는 기법입니다.

커링과 부분적용의 차이점은 매개변수를 전달하는 내부 매커니즘입니다.

- 커링은 부분 호출할 떄마다 단항 함수를 중첩 생성하며, 내부적으로 이들을 단계별로 합성하여 최종 결과를 냅니다.
- 부분 적용은 함수 인수를 미리 정의된 값으로 묶은 후 인수가 적은 함수를 새로 만듭니다. 후속 호출시 이미 평가를 마친 상태입니다.

```js
const curriedFn = function(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
};

const partialAppliedFn = function(a) {
  return function(b, c) {
    return a + b + c;
  };
};
```

부분적용과 커링 모두 유익한 기법입니다. 함수를 여러 단항 함수들로 몸집을 줄이는 동시에 자신의 스코프 밖에 위치한 객체에 접근하지 못하게끔 적정한 개수의 인수를 공급하는 효과가 있습니다.

## 함수 파이프라인을 합성

함수형 프로그래밍의 목표는 합성을 유도하는 필요한 자료구조를 얻는 것입니다. 부수효과 없는 함수는 외부 데이터에 절대 의존하지 않으며 필요한 정보는 반드시 인수를 통해서만 받습니다.
순수함수로 작성한 프로그램은 그 자체로 순수한 프로그램이므로 시스템의 다른 부분을 손대지 않아도 더 복잡한 프로그램의 일부로 합성할 수 있습니다.

### 함수 합성: 서술과 평가를 구분

함수 합성이란 복잡한 작업을 한데 묶어 간단한 작업으로 쪼개는 과정입니다.

```js
const str = "abdc";
const explode = str => str.split(/\s+/);
const count = arr => arr.length;

const countWords = R.compose(
  count,
  explode
);
countWords(str); // 4
```

countWords 하기 전에는 아무 평가도 하지 않습니다. 함수의 서술부와 평가부를 분리하는 함수 합성의 미학입니다.

두 함수 f와 g 의 입출력 형식이 맞아야 합성이 가능합니다.

```text
g :: A -> B
f :: B -> C
f g = f(g) = compose :: ((B -> C), (A -> B)) -> (A -> C))
```

형식이 호환되는 함수를 경계선 부근에서 느슨하게 묶는 합성은 인터페이스에 따른 프로그래밍의 원리와 일맥상통합니다.

```js
function compose() {
  let args = arguments;
  let start = args.length - 1;
  return function() {
    let i = start;
    let result = args[start].apply(this, arguments);

    while (i--) {
      result = args[i].call(this, result);
      return result;
    }
  };
}
```

### 함수형 라이브러리로 합성

```js
const smartestStudent = R.compose(
  R.head,
  R.pluck(0),
  R.reverse,
  R.sortBy(R.prop(1)),
  R.zip
);

smartestStudent(students, grades);
```

### 순수/불순 함수 다루기

불순한 코드는 실행 후 부수효과가 드러나고 외부 디펜던시 탓에 구성함수의 스코프 바깥에서 데이터에 접근할 수 밖에 없습니다. 순수/불순 함수 양쪽을 확실하게 구분하고 가급적 분순 코드를 격리하는 방법을 찾아야합니다. 이런 작업이 선행되어야 순수/불순 코드 조각을 합성하여 이어 붙일 수 있습니다.

### 무인수 프로그래밍

```js
R.compose(
  first,
  getName,
  reverse
);
```

기존 함수 선언과 달리 자신의 구성 함수의 매개변수를 하나도 드러내지 않습니다.
compose 함수를 사용하면 인수를 선언할 필요가 없기 때문에 간결하면서도 선언적인 무인수 코드를 작성할 수 있습니다. 이런 스타일을 암묵적 프로그래밍이라고도 합니다.

### 함수 조합기로 제어 흐름을 관리

조합기란 함수 또는 다른 조합기 같은 기본 장치를 조합하여 제어 로직처럼 작동시킬 수 있는 고계함수 입니다.
조합기는 대부분 함수형 프로그램이 잘 흘러가도록 조정하는 일이 주임무라 자신의 변수를 선언하거나 비즈니스 로직을 두진 않습니다.

- 항등 조합기
  identity 조합기는 주어진 인수와 똑같은 값을 반화하는 함수입니다.

```text
identity :: a -> a
```

- 탭 조합기
  tap 조합기는 코드 추가 없이 공형 함수를 연결하여 합성할 떄 아주 유용합니다.

```text
tap :: (a -> *) -> a -> a
```

- 선택 조합기
  alt 조합기는 함수 호출 시 기본 응답을 제공하는 단순 조건 로직을 수행합니다. 함수 2개를 인수로 받아 flase, null, undefined 가 아닌 값이 있으면 첫 번째 함수의 결과를 그렇지 않으면 두번째 함수의 결과를 반환합니다.

```js
const alt = function(func1, func2) {
  return function(val) {
    return func1(val) || func2(val);
  };
};
```

- 순차열 조합기
  seq 조합기는 함수 순차열을 순회합니다. 2개 또는 더 많은 함수를 인수로 받아, 동일한 값에 대해 각 함수를 차례대로 실행하는 또 다른 함수를 반환합니다. 이 조합기를 이용하면 서로 연관되어 있지만 독립적인 일련의 연산을 수행할 수 있습니다.

```js
const seq = function() {
  const funcs = Array.prototype.slice.call(arguments);
  return function(val) {
    funcs.forEach(function(fn) {
      fn(val);
    });
  };
};
```

- 포크 조합기
  fork 조합기는 하나의 자원을 두 가지 방법으로 처리 후 그 결과를 다시 조합합니다. 하나의 join 함수와 주어진 입력을 처리할 종단 함수 2개를 받습니다. (join 1 개 + fork 2개) 3개의 함수를 받습니다. 주어진 입력값에 fork 함수를 실행 후 최종 결과는 join 을 거쳐 합성됩니다.

```js
const fork = function(join, func1, func2) {
  return function(val) {
    return join(func1(val), func2(val));
  };
};
```

## 정리

- 함수형 체인과 파이프라인은 재사용 가능한 모듈적인 프로그램 조각들을 연결합니다.
- 커링, 부분적용을 하면 함수 인수를 일부만 평가하거나 단항 함수로 변환하여 함수 항수를 낮출 수 있습니다.
- 작업을 단순한 함수들로 쪼갠 후 다시 조합하는 식으로 전체 해법에 도달합니다.
- 조합기를 사용하면 복잡한 프로그램의 흐름을 조화롭게 편성하고 무인수 스타일로 개발할 수 있습니다.

## 이번주 문제

4개의 인자를 받아 대문자로 변환하여 역순으로 출력하라.

```text
func('a')('b')('c')('d') => DCBA
```

## 저번주 문제풀이

현섭님: 푸는중 ....
보람님: https://fp-study-today-bpfbdm.stackblitz.io
