# Chap 07. 함수형 프로그래밍 스터디

## 함수형 최적화

> 자그마한 효율은 그냥 잊으세요. 대략 97% 의 경우 어설픈 최적화가 모든 걸 망쳐놓는 원인이 됩니다. 하지만 나머지 결정적 3%는 최적화할 기화를 절대로 놓쳐서는 안됩니다.

함수형 프로그래밍은 코드 주위에 추상화 계층을 제공하여 유창함과 선언성을 실현합니다.
내부적으로 재귀, 커링, 모나드 래핑 등을 조합하여 해결하는 과정을 보면서 성능 문제를 고민하게됩니다.
FP 는 명령형 코드보다 성능이 나쁘지 않습니다.

함수형 프로그래밍은 개별 함수의 평가 속도를 올리기보다는 함수 중복 호출을 피해서 필요한 순간까지 평가를 지연시키는 전략을 구사합니다.

### 함수 실행의 내부 작동 원리

자바스크립트에서는 함수를 호출할 때마다 함수 컨텍스트 스택에 레코드가 생성됩니다.
컨텍스트 스택이란 함수 실행 및 함수가 감싼 변수를 관리하는 자바스크립트 프로그래밍 모델입니다.
전역 컨텍스트 프레임은 항상 스택 맨 및에 위치합니다. 함수 컨텍스트 프레임은 내부 지역 변수의 개수만큼 메모리를 점유합니다.

함수 본체에 변수를 많이 선언할수록 당연히 스택 프레임은 커집니다.

```js
executionContextData = {
  scopeChain, // 함수 자신의 variableObject, 부모의 variableObject에 접근하는 연결고리입니다.
  variableObject, // 함수의 인수 내부 변수, 함수 선언부를 포함
  this // 함수 객체를 가리키는 레퍼런스
}
```

- variableObject 은 지역 변수와 함수, 함수의 인수, arguments 객체를 가리키는 속성입니다.
- scopeChain 함수 자신의 컨텍스트와 부모 실행 컨텍스트와 연결하거나 참조합니다.

스택의 작동 규칙은 아래와 같습니다.

- 자바스크립트는 단일 스레드로 작동합니다. 동기 실행 방식으로 동작합니다.
- 전역 컨텍스트는 하나만 존재합니다.
- 함수 컨텍스트 개수에 제한은 없습니다. (모든 컨텍스트는 전역 컨텍스트를 공유합니다)
- 함수를 호출할 때마다 실행 컨텍스트가 새로 생성되며, 자기 자신을 재귀 호출하는 경우도 마찬가지입니다.

### 커링과 함수 컨텐스트 스택

추상화를 한 꺼풀 더 입히면 일반적인 함수 평가보다 컨텍스트에 오버헤드가 더 많이 발생할 수 있습니다.

```js
const logger = function(appender, layout, name, level, message)

function logger() {
  return (){
    return (){
      return (){
        // ....
      }
    }
  }
}
```

중첩구조는 한 번에 호출하는 것보다 함수 스택을 더 많이 사용합니다.
logger 함수를 커링 없이 실행하면 자바스크립트는 동기 실행됩니다. 그렇기 때문에 전역 컨텍스트 실행을 잠시 멈추고 새로운 활성 컨텍스트를 만들고, 변수 해석에 사용할 전역 컨텍스트 레퍼런스를 만듭니다.

logger 함수는 그 안에서 다른 Log4js 연산을 호출하므로 새 함수 컨텍스트가 생성되어 스택에 쌓입니다.
자바스크립트 클로저 때문에 내부 함수 호출로 비롯된 함수 컨텍스트는 다른 컨텍스트 위에 차곡차곡 쌓이며, 컨텍스트는 일정 메모리를 차지한 채 scopeChain 을 통해 연결됩니다.
Log4js 실행이 마무리된 후 런타임은 처음 상태로 돌아가게 되고, 전역 컨텍스트만 남게됩니다.

하지만 함수가 깊이 중첩되면 메모리를 과다하게 점유할 가능성이 있습니다.
모든 함수를 커리하면 항상 좋을 것 같지만 과용하면 엄청난 메모리가 소모됩니다.

비효율적으로, 부정확하게 구현한 재귀 코드 역시 종종 스택 넘침을 유발합니다.

### 재귀 코드의 문제점

잘못 구현된 재귀 호출하면 스택이 넘칠 수 있습니다.
브라우저에서 생성 가능한 함수 스택의 크기는 다음 스크립트로 가늠할 수 있습니다.

```js
function increment(i) {
  console.log(i);
  increment((i += 1));
}
increment(1);
```

코드의 재귀 호출 횟수는 이보다 훨씬 아래여야 하며, 그렇지 않으면 재귀 도중 버그가 발생합니다.
원소가 아주 많은 리스트의 경우 map, filter, reduce 등의 고계함수를 이용하여 탐색하는 방법이 좋습니다. 이런 함수를 사용한다면 함수 호출을 중첩하지 않고 반복할 때마다 스택을 재활용 할 수 있습니다.
커링과 재귀를 함수에 적용하면 명령형 코드보다 메모리를 더 차지하겠지만, 커링을 통한 유연성 및 재사용 측면에서 얻는 이득과 재귀 해법이 선사하는 정확성을 생각한다면 사용을 고려해봄직합니다.

함수형 프로그래밍은 불가능한 최적화를 실현합니다. 수 많은 함수를 스택에 올려놓으면 메모리 점유율이 높아집니다. 함수를 한꺼번에 묶어서 호출하면 안될까요 ?

### 느긋한 평가로 실행을 늦춤

불필요한 함수 호출을 삼가고 필요한 입력만 넣고 실행하면 성능 향상을 기대할 수 있습니다. 하스켈 같은 함수형 언어는 기본적으로 함수 표현식을 느긋하게 평가하도록 지원합니다.
자바스크립트는 바인딩과 동시에 표현식 평가를 마칩니다. 이를 탐욕스런 평가라고도합니다.
느긋한 평가는 어떻게 활용할 수 있을까요 ?

- 불필요한 계산을 피한다
- 함수형 라이브러리에서 단축 융합을 사용합니다

### 대체 함수형 조합으로 계산을 회피

가장 단순한 방법은 함수를 레퍼런스로 전달하고 조건에 따라 한쪽만 호출하여 쓸데없는 계산을 건너뛰는 것 입니다.
실행전에 전체 프로그램을 미리 정의해서 함수형 라이브러리로 단축 융합이라는 최적화를 수행하게 하는 방법도 있습니다.

### 단축 융합을 활용

```js
_.chain([p1, p2, p3, p4, p5, p6])
  .filter(isValid)
  .map()
  .values()
  .reverse()
  .value();
```

value 함수가 실행되면 전체 함수 순차열을 모두 실행시킵니다. 이렇게 하면 프로그램의 서술부와 실행부를 나눌 수 있습니다.
또 함수 실행중 차지하는 공간을 lodash 가 효율적으로 통합하여 최적화를 해줍니다.

이처럼 선언적인 형태로 작성하는건 하고 싶은 일을 미리 정함으로써 함수가 어떻게 작동하든 신경 쓰지 않고 무슨일을 해야되는지만 밝힙니다.

단축융합이라는 기법으로 lodah 가 프로그램 실행을 내부적으로 최적화 할 수 있습니다.

- 참조 투명성에 관한 함수형 프로그램의 엄격한 규칙
- 정합 관계가 성립

### 필요할 떄 부르리 전략

반복적인 계산을 피하는 것도 애플리케이션 실행 속도를 끌어올리는 방법입니다.
키/값 쌍을 캐시에 보관합니다. 캐시란 값비싼 연산을 하기 전에 질의하는 중간 저장소/메모리입니다.

### 메모화

메모화 배후의 캐시 전략도 함수 인수로 키값을 만들고 이 키로 계산 결과를 캐시에 보관해두었다가 이후 다시 같은 인수로 함수를 호출하면 보관된 결과를 즉시 반환한다는 로직은 같습니다.

### 계산량이 많은 함수를 메호화

자바스크립트나 파이썬 같은 언어에서는 함수를 언제 메모할지 선택할 수 있습니다.
메모화를 하면 동일한 입력으로 함수를 재호출할 때 내부 캐시가 히트되어 결과가 반환됩니다.

```js
function memoized() {
  let key = JSON.stringify(arguments);
  this._cache = this._cache || {};

  this._cache[key] = this._cache[key] || this.apply(this, arguments);

  return this._cache[key];
}

function memoize() {
  let fn = this;
  if (fn.length === 0 || fn.length > 1) {
    return fn;
  }
  return function() {
    return memoized.apply(fn, arguments);
  };
}
```

### 커링과 메모화를 활용

인수가 여러개인 함수는 순수함수라 해도 캐시하기 어렵습니다. 캐시 계층에서 추가 오버헤드가 안생기게 하려면 키값 생성 연산이 단순해야 하는데 더 복잡해집니다. 다항 함수를 단항함수로 만들면 다루기 쉽고 합성도 쉽습니다.
프로그램을 더 잘게 분해하여 전체를 구성하는 요소별로 메모화하고 캐시를 적용하는 이점을 살릴 수 있습니다.

### 분해하여 메모를 극대화

코드를 잘게 나눌수록 메모화 효과는 더욱 커집니다. 프로그램을 자신과 닮은 메모화 가능한 작은 하위 작업으로 쪼개는 재귀 역시 분해의 한 종류입니다. 성능이 좋지 않은 재귀 알고리즘도 메모화를 하면 빠른 알고리즘으로 거듭날 수 있습니다.

### 재귀 호출에도 메모화를 적용

재귀는 기저 케이스에 도달할 떄까지 큰 문제의 하위 문제들을 풀어 마지막 스택이 풀리며 최종 결과를 냅니다.
하위 문제들의 결과를 캐시하면 같은 함수를 호출할 때 성능을 끌어 올릴 수 있습니다.

```text
3! = 3 * 2 * 1 = 6

const factorial = ((n) => (n === 0) ? 1 : (n * factorial(n-1)).memoize())
```

factorial(100)을 실행하면 전체 알고리즘을 실행하며 100 개의 프레임을 함수 스택에 쌓습니다.
재귀는 스택공간을 너무 많이 허비하는 경향이 있습니다.
메모화를 이용하면 다음 숫자를 계산할 때 필요한 스택 프레임 개수를 엄청나게 줄일 수 있습니다.

### 재귀와 꼬리 호출 최적화

재귀 프로그램은 재귀가 없는 일반 프로그램보다 스택 소비량이 훨씬 많습니다.
재귀를 일반 루프만큼 실행을 최적화할 방법은 없을까요? 컴파일러가 꼬리 재귀 호출을 수행하게끔 재귀 알고리즘을 짜면 됩니다.

```js
const factorial = (n, current = 1) =>
  n === 1 ? current : factorial(n - 1, n * current);
```

TCO 는 꼬리 호출 제거라고도 합니다. ES6 부터 신설된 컴파일러 개선 항목으로써, 재귀 호출 실행을 단일 프레임으로 눌러펴 실행합니다.
재귀 함수가 가장 마지막에 함수를 호출하면, 자바스크립트 런타임은 남은 할 일이 없기 때문에 현재 스택 프레임을 붙들고 있을 이유가 없다고 판단하여 폐기합니다. 함수 컨텐스트에서 필요한 상태 값은 대부분 인수 형태로 함수에 넘기면 됩니다.

### 비꼬리 호출을 꼬리 호출로 전환

자바스크립트의 TCO 체제를 활용하여 함수를 최적화해봅니다.
n 계승을 계산하는 초기 버전의 재귀함수는 아래와 같습니다.

```js
const factorial = n => (n === 1 ? 1 : n * factorial(n - 1));
```

재귀 단계 값과 숫자 n 을 곱한 결과를 마지막에 반환하므로 꼬리 호출이 아닙니다.

- 곱셈 부분을 함수의 매개변수로 추가하여 현재 곱셈을 추적해야합니다.
- 기본 인수 값을 미리 정합니다.

```js
const factorial = (n, current = 1) =>
  n === 1 ? current : factorial(n - 1, n * current);
```

꼬리 재귀는 재귀 루프의 성능을 거의 수동 루프와 맞먹을 정도로 끌어올립니다.
유의할점은 TCO 가 ES4 초안이 나온 이후 자바스크립트 표준이 되었지만 아직 이를 지원하지 않는 브라우저가 더 많습니다.

### 마치며

- 함수형 코드는 명령형 코드보다 더 느리게 실행되거나 더 많은 메모리를 점유하는 경우가 있습니다.
- 느긋하게 평가하는 지연 전략을 구사 할 수 있습니다.
- 캐시전략으로 값비싼 함수를 중복 평가하지 않을 수 있습니다.
- 단순 함수로 분해하면 메모화를 통해 보다 효율적인 확장 가능한 코드로 개발할 수 있습니다.
- 컨텍스트 스택 사용까지 최적화하기 위해 메모화를 활용하세요
- 꼬리 재귀 함수로 바꾸면 꼬리 호출 최적화라는 컴파일러 확장 기능을 활용할 여지가 생깁니다.


### 문제 

api call 을 캐싱할 수 있는 memoize 를 만들어보자