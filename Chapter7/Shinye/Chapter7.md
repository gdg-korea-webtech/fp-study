Quiz)

- 피보나치를 메모이제이션으로 구현해보자	[링크](https://github.com/FEDevelopers/tech.description/wiki/%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)



# 함수형 최적화

함수형 프로그래밍은 개별 함수의 평가 속도를 올리기 보다는, 주로 함수 중복 호출을 피해서 코드가 정말 필요할 때 까지 평가를 지연시키는 전략을 구사한다.



### 1. 함수 실행의 내부 작동 원리

- FP에서는 만사가 함수를 평가하며 움직임

- JS에서는 함수를 호출할 떄 마다 함수 콘텍스트 스택에 레코드가 생성된다.

- 커링과 함수 콘텍스트 스택

  ```javascript
  const logger = function (appender, layout, name, level, message)
  
  // currying
  const logger = 
  	function (appender) {
          return function (layout) {
              return function (name) {
                  return function (level) {
                      return function (message) {
                          // ...
                      }
                  }
              }
          }
  	}
  ```

  - 중첩구조는 한 번에 호출하는 것 보다 함수 스택을 더 많이 쓴다.
  - 커링은 좋은 알고리즘이지만, 함수가 깊이 중첩되면 메모리를 과다하게 점유할 가능성이 있다. 그래서 비동기 코드를 다루는 RxJS같은 것을 쓰기도 한다.

### 2. 느긋한 평가로 실행을 늦춤

- 불필요한 함수 호출을 삼가고 꼭 필요한 입력만 넣고 실행하면 여러모로 성능 향상을 기대할 수 있다.

- 자바스ㄴ크립트는 기본적으로 함수를 빠르게 평가한다. (greedy evalutation)

- 따라서 다음과 같은 방식을 기본으로 한다.

  - 불필요한 계산을 피한다.
  - 함수형 라이브러리에서 단축 융합을 사용한다.

- 대체 함수형 조합으로 계산을 회피한다.

- 단축 융합을 활용

  - lodash의 chaining처럼 선언적 형태로 프로그램을 작성하는 건, 하고 싶은 일을 미리 정의함으로써 함수가 어떻게 작동하든 신겨 ㅇ안쓰고 무슨 일을 해야하는지에 집중한다는 의미이다.

  - 덕분에 단축 융합이라는 기법으로 로대시가 프로그램 실행을 내부적으로 최적화 할 수 있다.

  - 자료구조가 줄면 대량 데이터 처리 시 필요한 과도한 메모리 사용을 줄일 수 있다.

    - FP의 참조 투명성에 대한 엄격함 덕분이다.

    ```javascript
    const square = (x) => Math.pow(x,2);
    const isEven = (x) => x%2 === 0;
    const numbers = _.range(200);
    
    const result = 
    	_(numbers).map(square).filter(isEven).take(3).value(); // [0,4,16]
    ```



### 3. '필요할때 부르리' 전략

- 반복적인 계산을 피하는 것도 애플리케이션 실행 속도를 끌어올리는 좋은 방법.

- 대표적인 예가 `캐싱` 이다.

  - 캐싱(Caching)은 애플리케이션의 처리 속도를 높여준다. 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있다. 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.

- 메모화

  - 계산량이 많은 함수를 메모화.

    - 순수 함수형 언어는 자동화는 메모화를 실천하지만, JS나 파이썬은 함수를 언제 메모할지 선택할 수 있다.

  - 커링과 메모화를 활용

    - 복잡한 함수는 아무리 순수함수라 해도 캐싱하기 어렵다.

    - 따라서 캐시 계층에서 추가 오버헤드가 안생기게 하려면 키값 생성이 단순해야 하는데 외려 복잡해지기 떄문.

    - 따라서 커링을 활용한다.

      ```javascript
      const safeFindObject = R.curry((db, ssn) => //... )
      const findStudent = safeFindObject(DB('students')).memoize();
      findStudent(...);
      ```

  - 재귀호출에도 메모화를 사용한다.
  - 분해하여 메모화를 극대화
    - 문제를 메모화 가능한 함수로 잘게 나누는 행위는 도움이 된다.
    - 코드를 잘게 나눌수록 메모화의 효과는 크다.
    - 어떤 함수라도 내부에 캐시장치를 달면 프로그램을 빨리 평가하기 때문이다.



### 4. 재귀와 꼬리 호출 최적화

- 재귀를 일반 루프만큼 실행을 최적화 하는 방법 => 꼬리 재귀 호출 방법을 활용하여 알고리즘을 짜면 된다.

  ```javascript
  const factorial = (n, cur = 1) => 
  	(n === 1) ? cur : factorial(n - 1, n*cur);
  ```

- 재귀 함수가 가장 마지막에 함수를 호출하면, 자바스크립트 런타임은 남은 할 일이 없기 때문에 더 이상 현재 스택 프레임을 붙잡고 있을 이유가 없다.

- 함수 콘텍스트에서 상태 값은 대부분 인수 형태로 다음 함수에 넘긴다.

  - 이러한 재귀를 반복하면 스택에 새 프레임이 쌓이지 않고 이전에 쓴 프레임을 재활용 가능하다.

