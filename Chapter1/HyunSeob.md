# 1. 함수형 길들이기

# 1.1 함수형 프로그래밍은 과연 유용한가?

> 객체지향은 움직이는 부분(가동부)를 캡슐화하여 코드의 이해를 돕는다. 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드의 이해를 돕는다.

여기서 움직이는 부분이란, 사이드 이펙트나, 변수사용 등을 말한다.(고 생각함)

- 요즘 웹 어플리케이션은 예전과 달리 많이 복잡해졌다.
- 객체지향으로도 해결할 수 있지만, 부족하다.
- 요즘 함수형 프로그래밍이 뜨고있다.
- 자바스크립트에서는 더더욱 FP가 필요하다.

# 1.2 함수형 프로그래밍이란?

- 함수형 프로그래밍의 목표는

  - 사이드 이펙트를 방지하고
  - 상태 변이를 최소화하고
  - 데이터의 제어흐름과 연산을 추상화하는 것

```javascript
function addToDom(elementId) {
  return function(node) {
    document.querySelector(`#${elementId}`).innerHTML = node;
  };
}

function h1(children) {
  return `<h1>${children}</h1>`;
}

function echo(value) {
  return value;
}

// lodash의 flowRight나 compose등과 유사한 합성 함수
function compose(...functions) {
  return function(x) {
    return functions.reduceRight((y, f) => f(y), x);
  };
}

// 아주 작은 함수들을 합성해 새로운 함수를 만들었다.
const printMessage = compose(
  addToDom("app"),
  h1,
  echo // 얘는 사실 필요없는데 왜 넣는지 의문
);

printMessage("Hello world!");
```

> 실제동작: [functional-js-1 - StackBlitz](https://stackblitz.com/edit/functional-js-1)

- 함수형 프로그래밍에서는 매개변수가 오직 스칼라 값이 아니라 함수 그 자체가 될 수 있다.
- 즉 함수를 매개변수화 한다.

## 1.2.1 함수형 프로그래밍은 선언적

- 함수형 프로그래밍은 선언형 프로그래밍 패러다임에 속한다.
- 명령형 프로그래밍에서는 컴퓨터에게 원하는 작업을 어떻게 하는지 상세하게 설명한다.

예)

---

```javascript
var i = 0;
// 종료조건으로 i의 값이 10보다 작다면 true, 같거나 크다면 false가 된다.
while (i < 10) {
  // 반복이 실행될 때마다 coding everybody 이 출력된다.
  document.write("coding everybody");
  // i의 값이 1씩 증가한다.
  i++;
}
```

- 변수 `i`가 가르키는 메모리 공간이 있고 이 공간에 값 0을 초기화합니다.
- `while` 루프에서 변수 `i`가 가르키는 메모리 공간의 값을 읽어 이 값이 10보다 크면 루프를 빠져 나가고 아니면 다음 코드를 수행합니다.
- 문자열을 출력하고, 변수 `i`가 가르키는 메모리 공간의 값을 읽어 1을 더한 다음에 이 값을 다시 변수 `i`가 가르키는 메모리 공간에 씁니다.
- 다시 `while` 루프를 반복합니다.

---

- 선언형 프로그래밍 패러다임에서는 "어떻게"보다는 "무엇"을 설명한다.

```javascript
// 해당 문장을 10번 출력해라.
_.times(10, function() {
  document.write("coding everybody");
});
```

- 루프 카운터를 관리하고 배열 인덱스에 정확하게 접근할 필요가 없다.

> 참고: [프로그래밍 입문서의 문제점](https://kwangyulseo.com/2015/06/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8%EC%84%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/)

- 루프는 재사용하기도 어렵고 다른 연산에 끼워넣기도 어렵다.
- 상태를 두지 않으려면 사이드 이펙트나 상태 변이가 없는 순수함수를 써야한다.

## 1.2.2 순수함수와 부수효과

- 순수함수는 주어진 입력에만 의존한다.
- 외부 상태와 무관하게 동작한다.
- 함수 스코프 밖의 변경을 일으키지 않는다 (사이드 이펙트가 없다)
- 사이드 이펙트가 발생하는 상황
  - 전역 스코프의 변수를 변경
  - 인수로 전달받은 값을 변경
  - 사용자 입력 처리
  - 예외를 함수 내에서 처리하지 않고 그냥 throw함
  - 화면/로그 출력
  - HTML 문서 조작, 브라우저 쿠키, DB에 질의
- 프로그램 특성상 상태 변이를 아예 없앨수는 없다.
- 하지만 상태 변이를 줄이고, 관리할 수 있도록 순수함수와 불순함수를 구분하자

## 1.2.3 참조 투명성과 치환성

- 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내는 경우, 참조 투명한 함수라고 부른다.

## 1.2.4 불변 데이터 유지하기

- 객체를 인수로 전달할 경우,
- call by value가 아니라 call by reference라 내부에서 객체를 수정하면
- 사이드 이펙트를 일으킨다.

# 1.3 함수형 프로그래밍의 좋은 점

## 1.3.1 복잡한 작업을 분해하도록 유도

- 함수형 프로그래밍은 프로그램을 분해하고 합성하는 것들의 상호작용이다.
- 단일성: 함수는 한 가지 목표만 바라봐야 한다.

## 1.3.2 데이터를 매끄럽게 체이닝하여 처리

- 체인은 같은 객체를 반환하는 순차적인 함수 호출이다.
- 로대시의 함수 체인은 필요한 시점까지 실행을 미루는 Lazy Evaluation 방식이다.

## 1.3.3 복잡한 비동기 애플리케이션에서도 신속하게 반응

- 리액티브 프로그래밍을 사용하면 비동기, 이벤트 핸들링등을 잊고 비즈니스 로직에 전념할 수 있다.
- 리액티브 프로그래밍은 함수형 프로그래밍에 기반을 두었으므로 함수형을 잘 할 수 있다면 리액티브도 절반은 끝난 셈이다.
- 결과적으로 함수형 리액티브 프로그래밍을 하게 된다.
- 함수형 프로그래밍을 시작했다고 해서 모든 코드를 함수형으로 바꿀 필요는 없다.
- 객체지향 프로그래밍과 적당히 섞어도 된다.
- 함수형 프로그래밍은 변이와 공유 상태를 엄격하게 통제하므로 멀티스레드 프로그램도 직관적으로 작성 가능하다.

# 이번 주 문제

아래 처럼 동작할 수 있도록 `filter`, `pluck`, `average` 함수를 작성한다.

    const enrollment = [
      { enrolled: 2, grade: 100 },
      { enrolled: 2, grade: 80 },
      { enrolled: 1, grade: 89 },
    ]

    const calculateAverage = compose(
      filter(student => student.enrolled > 1),
      pluck('grade'),
      average,
      console.log
    )

    calculateAverage(enrollment) // 90
