# 2. 고계 자바스크립트

# 2.1 왜 자바스크립트인가?

- 편재성: 어디에나 있기 때문, 어느 언어보다 폭 넓게 쓰인다
- 자바스크립트는 함수형 언어의 영향도 많이 받았다.
  - 고계함수 (High order function)
  - 클로저
  - 배열 리터럴
- 자바스크립트는 아직도 진화 중이다
- 하지만 자바스크립트는 함수형인 동시에 객체지향언어다.

# 2.2 함수형 대 객체지향 프로그래밍

- 객체지향과 함수형의 가장 중요한 차이점은 객체의 속성과 기능을 조직하는 방법에 있다.
- 객체지향: 객체의 캡슐화에 강하게 의존한다. 객체의 데이터와 기능은 단단히 결합된다.
- 함수형: 데이터는 불변이기 때문에 데이터를 숨기지 않으며, 데이터와 기능을 느슨하게 결합한다.

## 2.2.1 자바스크립트 객체의 상태관리

- 객체상태를 보호하는 측면에서 자바스크립트는 최악의 언어다.
- 자바스크립트에서는 언제건 속성을 추가, 삭제, 수정할 수 있다.

## 2.2.2 객체를 값으로 취급

- 모든 객체를 값(즉 불변으로) 취급해야 한다.
- 하지만 자바스크립트에서는 객체 내부 변수가 불변이 아니다. 언제라도 바꿀 수 있다.
- 상수는 `const`를 사용하여 바뀌지 않도록 선언할 수 있다.
- 하지만 `const`로는 부족하다.
- 클로저를 이용하여 값 객체 패턴을 사용할 수 있다.

## 2.2.3 가동부를 깊이 동결

- `Object.freeze()`를 사용하면 `writable`속성을 `false`로 설정하여 객체 상태를 바꿀 수 없게 한다.
- 하지만 중첩된 객체를 동결하는 것은 아니다. (Shallow freeze)
- `Object.freeze()`를 재귀호출 하여 Deep freeze를 구현할 수 있다.

## 2.2.4 객체 그래프를 렌즈로 탐색/수정

- Copy on write, 값을 입력할 때마다 새 객체를 만들어 반환하는 방식이 있지만, 매우 번거롭다.
- 렌즈는 해당 방식과 비슷하게 동작한다. Ramda.js를 쓰면 사용할 수 있다.

# 2.3 함수

## 2.3.1 함수를 일급 시민으로

- 자바스크립트에서 함수는 객체이므로 일급시민이다.
- 일급시민이라는 것은 변수에 할당 가능하다는 것을 의미한다.

## 2.3.2 고계함수

- 함수는 다른 함수의 인수로 전달하거나 값으로서 반환될 수 있다.
- 이런 함수를 고계함수라고 부른다.
- 자바스크립트 함수는 일급 시민이자 고계라서 값과 다를 바 없다.

## 2.3.3 함수 호출 유형

- 함수 내에서 `this`를 사용하는 경우 실행 컨텍스트에 따라 불러오는 값이 다르다.
- `this`는 웬만하면 쓰지마라

## 2.3.4 함수 메서드

- `apply` `call` 은 기존 함수에서 새 함수를 만들어 쓰는 용도로 쓴다.

# 2.4 클로저와 스코프

- 자바스크립트 이전에 클로저는 순수 FP 언어에만 존재했다.
- 클로저는 함수를 선언할 당시의 환경에 함수를 묶어둔 자료구조
- 클로저는 함수의 스코프를 상속한 것이다.
- 클로저는 스코프 내의 변수들의 스냅샷을 간직한다.

## 2.4.1 전역 스코프의 문제점

- 모든 자바스크립트 코드가 자유롭게 접근할 수 있으므로 변화되기 쉽다.
- 네임스페이스가 충돌할 소지가 매우 높다.
- 예기치 않은 오버라이드가 발생할 수 있다.

## 2.4.2 자바스크립트의 함수 스코프

- 가장 일반적인 자바스크립트의 스코프.
- 함수 내부에 선언된 변수들은 모두 지역변수다.

## 2.4.3 의사 블록 스코프

- 자바스크립트는 블록 수준의 스코프를 지원하지 않는다.
- `var`를 사용하면 호이스팅이 일어난다.
- `let`을 사용하면 호이스팅으로 일어나는 문제를 어느정도 방지할 수 있다.

## 2.4.4 클로저 응용

- 클로저에 모듈 패턴을 응용하면 프라이빗 변수를 모방할 수 있다.
- 비동기 이벤트 처리시 콜백 패턴을 사용하는 경우에도 클로저가 사용된다.
- 루프 문의 스코프 문제는 고계함수와 클로저를 사용해 스코프를 만드는 것으로 해결할 수 있다.

# 2주차 문제

아래처럼 동작하는 함수 `makeHttpClient`를 구현하세요.

```javascript
const httpClient = makeHttpClient({ baseURL: "https://github.com/api" });

httpClient.get("/users"); // 콘솔에 `GET: https://github.com/api/users` 출력
httpClient.post("/groups"); // 콘솔에 `POST: https://github.com/api/groups` 출력
```
